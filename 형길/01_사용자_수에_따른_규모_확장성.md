# 1장. 사용자 수에 따른 규모 확장성

한명의 사용자를 지원하는 시스템에서 시작하여 몇백만 사용자를 지원하는 시스템을 설계해보자

<br>

## 단일 서버

모든 컴포넌트가 단 한 대의 서버에서 실행되는 시스템부터 설계해보자

### 그림 1.1

웹 앱, DB, 캐시 등이 전부 서버 한 대에서 실행

이 그림의 시스템 구성을 이해하기 위해서는 사용자의 요청이 처리되는 과정과 요청을 만드는 단말에 대해서 이해

### 그림 1.2

사용자의 요청 흐름

1. 사용자는 도메인 이름(api.mysite.com)을 이용하여 웹사이트에 접속

    이 접속을 위해서는 도메인 이름을 DNS에 질의하여 IP 주소로 변환하는 과정 필요

    DNS는 보통 제3 사업자(써드파티)가 제공하는 유료 서비스를 이용

2. DNS 조회 결과로 IP 주소 반환

3. 해당 IP 주소로 HTTP 요청이 전달

4. 요청을 받은 웹 서버는 HTML 페이지나 JSON 형태의 응답을 반환

<br>

실제 요청이 어디서 오는지 살펴보자

웹 앱과 모바일 앱과 구분

- 웹 애플리케이션

    비즈니스 로직, 데이터 저장 등을 처리하기 위해서는 서버 구현용 언어(자바, 파이썬 등)를 사용

    프레젠테이션 용으로는 클라이언트 구현용 언어(HTML, 자바스크립트 등)를 사용

<br>

- 모바일 앱

    모바일 앱과 웹 서버 간 통신을 위해서는 HTTP 프로토콜을 이용

    반환 응답 데이터 포맷은 보통 JSON

<br>

## 데이터베이스

사용자가 늘면 서버 하나로는 부족하기에 여러 서버가 필요

### 그림 1.3

하나는 웹/모바일 트래픽 처리 용도, 다른 하나는 DB 용도

웹 계층과 데이터 계층을 분리하면 그 각각을 독립적으로 확장 가능

<br>

### 어떤 DB를 사용할 것인가

RDBMS VS NoSQL

- RDBMS

    MySQL, 오라클, PostgreSQL ...

    자료를 테이블과 열, 칼럼으로 표현

    SQL을 사용하여 여러 테이블에 있는 데이터를 그 관계에 따라 join하여 합칠 수 있음

- NoSQL

    Cassandra, MongoDB, DynamoDB ...

    key-value store, graph store, column store, document store

    join 연산 지원 X

<br>

NoSQL이 바람직한 조건

- 아주 낮은 응답 지연시간이 필요

- 다루는 데이터가 비정형

- 데이터(JSON, YAML ...)를 직렬화(serialize), 역직렬화(deserialize)를 하기만 하면 되는 경우

- 아주 많은 양의 데이터를 저장할 필요

<br>

## 수직적 규모 확장 VS 수평적 규모 확장

수직적 규모 확장 = scale up

- `서버에 고사양 자원(더 좋은 CPU, 더 많은 RAM ...)을 추가하는 행위`

- 서버로 유입되는 트래픽의 양이 적을 때

- 단순함

- 한 대의 서버에 CPU나 메모리를 무한대로 증설할 방법 X

- 장애에 대한 자동 복구(failover) 방안이나 다중화 방안 제시 X

<br>

수평적 규모 확장 = scale out

- `더 많은 서버를 추가하여 성능을 개선하는 행위`

- 대규모 애플리케이션을 지원하는 것에 적절

<br>

### 로드밸런서

부하 분산 집합에 속한 웹 서버들에게 `트래픽 부하를 고르게 분산하는 역할`

### 그림 1.4

사용자는 로드밸런서의 공개 IP 주소로 접속

따라서, 웹 서버는 클라이언트의 접속을 직접 처리하지 않음

보안을 위해 서버 간 통신은 사설 IP 주소가 이용됨

사설 IP 주소란 같은 네트워크에 속한 서버 사이의 통신에만 쓰일 수 있는 IP 주소로 인터넷을 통해서는 접속 불가

로드밸런서는 웹 서버와 통신하기 위해 이 사설 주소를 이용

<br>

부하 분산 집합에 또 하나의 웹 서버를 추가하고 나면 failover 문제는 해소되고, 가용성은 향상

- 서버 1이 다운되면 모든 트래픽은 서버 2로 전송 -> 웹 사이트 전체가 다운되는 일 방지

- 트래픽이 가파르게 증가하면 로드밸런서로 대처 가능

<br>

### 데이터베이스 다중화

서버 사이에 Master-Slave 관계를 설정하고 원본은 master에 사본은 slave에 저장

Write는 Master에서만 지원

Slave DB는 Master DB로부터 사본을 전달받고 Read만 지원

INSERT, DELETE, UPDATE (SELECT를 제외한 DML)은 Master DB로만 전달

대부분의 애플리케이션은 Read의 비중이 훨씬 높음

따라서, Slave DB 수가 더 많음

### 그림 1.5

<br>

다중화의 이득

- 더 나은 성능
  
    Master-Slave로 나뉘어 분산 처리

    병렬로 처리될 수 있는 query의 수가 늘어나기에 성능 up

- 안정성

    지역적으로 떨어진 여러 장소에 다중화함으로써 데이터 보존

- 가용성

    하나의 DB 서버에 장애가 발생하더라도 다른 서버에 있는 데이터를 가져와 사용

<br>

DB 서버 가운데 하나가 다운되면 어떤 일이 벌어지는가?

- Slave가 1대인데 다운된 경우라면, Read는 한시적으로 모두 Master에게 전달

    바로 새로운 Slave DB가 장애 서버를 대체

- Master가 다운되면 다른 Slave가 Master를 대체

    production 환경에서 Slave에 보관된 데이터가 최신 상태가 아니면?

    없는 데이터는 복구 스크립트를 돌려서 추가

    다중 마스터나 원형 다중화 방식을 도입하면 도움이 될 수 있지만 매우 복잡

<br>

### 그림 1.6

1. 사용자는 DNS로부터 로드밸런서의 공개 IP 주소를 받음

2. 사용자는 해당 IP 주소를 사용해 로드밸런스에 접속

3. HTTP 요청은 서버 1이나 서버 2에 전달

4. 웹 서버는 사용자의 데이터를 Slave DB에서 읽음

5. 웹 서버는 SELECT를 제외한 DML을 Master DB로 전달

<br>

응답 시간을 개선하기 위해 캐시와 CDN을 추가해보자

<br>

## 캐시

캐시는 값비싼 연산 결과 또는 자주 참조되는 데이터를 메모리에 두고 뒤 이은 요청이 빨리 처리될 수 있도록 하는 저장소

웹 페이지를 새로고침할 때마다 표시할 데이터를 가져오기 위해 한 번 이상의 DB 호출이 발생

애플리케이션의 성능은 DB를 얼마나 자주 호출하느냐에 크게 좌우

캐시는 해당 문제를 완화할 수 있음

<br>

### 캐시 계층

캐시 계층은 데이터가 잠시 보관되는 곳으로 DB보다 훨씬 빠름

별도의 캐시 계층은 성능 개선 + DB 부하 줄임

<br>

### 그림 1.7

1. 요청받은 웹 서버는 캐시에 응답이 저장되어 있는지 확인

2. 저장되어 있다면 해당 데이터를 클라이언트에게 반환

3. 저장되어 있지 않다면 DB query를 통해 데이터를 찾아 캐시에 저장한 뒤 클라이언트에게 반환

이런 캐시 전략을 읽기 주도형 캐시 전략이라고 부름

다양한 캐시 전략이 존재하고 캐시할 데이터 종류, 크기, 액세스 패턴에 맞는 캐시 전략을 선택

<br>

캐시 서버를 이용하는 방법은 캐시 서버들이 제공하는 API를 활용

### 캐시 사용시 유의점

- `캐시는 어떤 상황에 바람직한가?`
  
    캐시는 데이터 갱신은 자주 일어나지 않고, 참조는 빈번하게 일어나면 고려

<br>

- `어떤 데이터를 캐시에 두어야 하는가?`

    캐시는 휘발성 메모리에 두므로 영속적으로 보관할 데이터는 캐시에 X

<br>

- `캐시에 보관된 데이터는 어떻게 만료되는가?`

    만료된 데이터는 캐시에서 삭제

    이에 대한 캐시 정책 마련이 필요

<br>

- `일관성은 어떻게 유지되는가?`

    DB와 캐시의 데이터가 일치하는지 여부가 중요

    여러 지역으로 시스템을 확장하는 경우 DB와 캐시의 일관성을 유지하기는 어려운 문제

    페이스북의 논문 Scaling Memcache at FaceBook 논문을 참고해보자

<br>

- `장애에는 어떻게 대처할 것인가?`

    캐시를 한 대만 두는 경우 SPOF(단일 장애 지점)이 되어버릴 가능성 존재

    SPOF란 어떤 특정 지점에서의 장애가 전체 시스템의 동작을 중단시켜버릴 수 있는 경우를 의미

    SPOF를 피하려면 여러 지역에 걸쳐 캐시 서버를 분산

<br>

- `캐시 메모리는 얼마나 크게 잡을 것인가?`

    너무 작으면 데이터가 너무 자주 캐시에서 밀려나 성능 저하

    캐시를 과할당해서 문제 해결

<br>

- `데이터 방출 정책은 무엇인가?`

    데이터 방출 정책이란 캐시가 꽉 찼을 때 추가 데이터를 넣어야 하는 경우 기존 데이터를 내보내는 것

    LRU(Least Recently Used) 사용

    LFU나 FIFO도 존재

<br>

## CDN(콘텐츠 전송 네트워크)

`CDN은 정적 콘텐츠를 전송하는 데 쓰이는 지리적으로 분산된 서버의 네트워크`

이미지, 비디오, CSS, JS 파일 등을 캐시할 수 있음

<br>

CDN은 어떻게 동작하나?

어떤 사용자가 웹사이트를 방문하면 그 사용자에게 가장 가까운 CDN 서버가 정적 콘텐츠를 전달

멀면 멀수록 천천히 로드

### 그림 1-9

### 그림 1-10

1. 사용자 A가 이미지 URL을 이용해 image.png에 접근

2. CDN 서버의 캐시에 해당 이미지가 없으면 원본 서버에 요청하여 파일을 가져옴

    웹 서버, S3 ...

3. 원본 서버가 파일을 CDN 서버에 반환

4. CDN 서버는 파일을 캐시하고 사용자 A에게 반환

    이미지는 원본 서버에서 올 때 HTTP 헤더에 적힌 TTL(Time To Live)에 명시된 시간이 끝날 때까지 캐시

5. 사용자 B가 같은 이미지에 대한 요청을 CDN 서버에 전송

6. 만료되지 않은 이미지에 대한 요청은 캐시를 통해 처리

<br>

### CDN 사용시 고려해야 할 사항

- 비용

    CDN으로 들어가고 나가는 데이터 전송 양에 따라 요금 측정

<br>

- 적절한 만료 시한 설정

    시의성이 중요한 콘텐츠의 경우 만료 시점 설정 중요

    너무 길면 신선도가 떨어지고, 너무 짧으면 원본 서버에 자주 접속해야 함

<br>

- CDN 장애에 대한 대처 방안

    CDN 자체가 죽었을 경우 웹사이트/애플리케이션이 어떻게 동작해야 하는지 고려

    해당 문제를 감지하여 원본 서버로부터 직접 콘텐츠를 가져오도록 구성

<br>

- 콘텐츠 무효화 방법

    아직 만료되지 않은 콘텐츠라고 하더라도 아래 방법 중 하나를 사용하면 CDN에서 제거 가능

    - CDN 사업자가 제공하는 API를 이용하여 콘텐츠 무효화
  
    - 콘텐츠의 다른 버전을 서비스하도록 오브젝트 버저닝 이용

<br>

### 그림 1.11

변화된 부분

- 정적 콘텐츠는 더이상 웹 서버를 통해 서비스되지 않으며, CDN을 통해 제공

- 캐시가 DB의 부하를 줄여줌

<br>

## 무상태(stateless) 웹 계층

이제 웹 계층을 수평적으로 확장하는 방법을 고민할 차례

상태 정보(사용자 세션 데이터와 같은)를 웹 계층에서 제거해야 함

상태 정보를 RDBMS나 NoSQL같은 지속성 저장소에 보관하고 필요할 때 가져오게끔

이렇게 구성된 웹 계층을 무상태 웹 계층이라고 부름

<br>

### 상태 정보 의존적인 아키텍처

상태 정보를 보관하는 서버와 그렇지 않은 서버 사이의 차이가 존재

상태 정보를 보관하는 서버는 클라이언트 정보를 유지하여 요청들 사이에 공유되도록 함

무상태 서버에는 이런 장치 X

### 그림 1-12

각각 사용자를 인증하기 위해 자신의 상태 정보가 있는 서버에 요청해야 하는 것이 문제

로드밸런서가 이를 지원하기 위해 고정 세션이라는 기능을 제공하지만 로드밸런서에 부담을 줌

<br>

### 무상태 아키텍처

### 그림 1.13

이 구조는 사용자로부터 HTTP 요청은 어떤 웹 서버로도 전달 가능

웹 서버가 상태 정보가 필요할 경우 공유 저장소로부터 데이터를 가져옴

따라서 상태 정보는 웹 서버로부터 물리적으로 분리

이런 구조는 단순하고, 안정적이고, 규모 확장이 쉬움

<br>

### 그림 1.14

세션 데이터를 웹 계층에서 분리하고 지속성 데이터 보관소에 저장하도록 만듦

이 공유 저장소는 RDBMS or Memcached/Redis 같은 캐시 시스템 or NoSQL

여기서는 NoSQL을 사용하였는데 규모 확장이 간편해서

(1)의 자동 규모 확장(AutoScaling)은 트래픽 양에 따라 웹 서버를 자동으로 추가하거나 삭제하는 기능

상태 정보가 웹 서버들로부터 제거됐으므로, 트래픽 양에 따라 웹 서버를 넣거나 빼기만 하면 자동으로 규모를 확장할 수 있음

<br>

## 데이터 센터

### 그림 1.15

장애가 없는 상황에서 사용자는 가장 가까운 데이터 센터로 안내, 이를 지리적 라우팅이라고 부름

geoDNS는 사용자의 위치에 따라 도메인 이름을 어떤 IP 주소로 변환할지 결정할 수 있도록 해주는 DNS 서비스

### 그림 1.16

데이터 센터 중 하나에 심각한 장애가 발생하면 모든 트래픽은 장애가 없는 데이터 센터로 전송

<br>

다중 데이터센터 아키텍처를 만드려면 몇 가지를 해결해야 함

- 트래픽 우회

    올바른 데이터 센터로 트래픽을 보내는 효과적인 방법을 찾아야 함

<br>

- 데이터 동기화

    데이터센터마다 별도의 DB를 사용하고 있지만 failover되어 트래픽이 다른 DB로 우회된다고 해도

    해당 데이터센터에는 찾는 데이터가 없을수도

    데이터를 여러 데이터센터에 걸쳐 다중화하는 것으로 해결

<br>

- 테스트와 배포

    여러 데이터센터를 사용하도록 시스템이 구성된 상황이라면 여러 위치에서 테스트를 해봐야 함

<br>

시스템을 더 큰 규모로 확장하기 위해서는 시스템의 컴포넌트를 분리하여 각기 독립적으로 확장될 수 있도록 해야 함

`메시지 큐는 많은 실제 분산 시스템이 해당 문제를 풀기 위해 사용하는 핵심 전략 중 하나`

<br>

## 메시지 큐

`메시지 큐는 메시지의 무손실(메시지 큐에 일단 보관된 메시지는 소비자가 꺼낼 때까지 안전히 보관된다는 특성)을 보장하는 비동기 통신을 지원하는 컴포넌트`

메시지의 버퍼 역할(모아서 쌓아 놓음)을 하며 비동기적으로 전송

생산자 또는 발행자(producer/publisher)라고 불리는 입력 서비스가 메시지를 만들어서 메시지 큐에 발행(publish)

큐에는 보통 소비자 또는 구독자(consumer/subscriber)라 불리는 서비스 혹은 서버가 연결되어 있는데 메시지를 받아 그에 맞는 동작을 수행하는 역할

### 그림 1.17

<br>

메시지 큐를 이용하면 서비스 또는 서버 간의 결합이 느슨해져서 안정적 애플리케이션을 구성하기 좋음

생산자는 소비자 프로세스가 다운되어 있어도 발행이 가능하고 소비자는 생산자 서비스가 가용한 상태가 아니더라도 메시지 수신이 가능

<br>

이미지의 크로핑, 샤프닝, 블러링 등을 지원하는 사진 보정 애플리케이션을 만든다고 하자

이런 보정은 시간이 오래걸리는 프로세스이므로 비동기적으로 처리하면 편함

### 그림 1.18

웹 서버는 사진 보정 작업을 메시지 큐에 넣고

사진 보정 작업 프로세스들은 이 작업을 메시지 큐에 꺼내어 비동기적으로 완료

<br>

## 로그, 메트릭 그리고 자동화

사업 규모가 커지면 로그, 메트릭, 자동화는 필수

- 로그

    에러 로그를 모니터링하는 것은 중요

    시스템의 오류와 문제를 찾을 수 있기 떄문

    로그를 단일 서비스로 모아주는 도구를 활용

<br>

- 메트릭

    사업 현황에 관한 유용한 정보를 얻을 수 있고, 시스템의 현재 상태를 파악

    호스트 단위 메트릭(CPU, 메모리, 디스크 I/O ...)

    종합 메트릭(DB 계층의 성능, 캐시 계층의 성능 ...)

    핵심 비즈니스 메트릭(일별 능동 사용자, 수익 ...)

<br>

- 자동화

    생산성을 높이기 위해 사용

    CI/CD

<br>

### 메시지 큐, 로그, 메트릭, 자동화 등을 반영하여 수정한 설계안

### 그림 1.19

<br>




